
                                      Добавляем автоматическую имплементацию DAO

  Чтобы начать использовать механизм автоматического создания DAO в Spring без Boot,
нужно добавить к конфигурационному классу приложения аннотацию @EnableJpaRepositories.

@EnableJpaRepositories(basePackages = "ru.practicum")
// остальные аннотации
public class PersistenceConfig {
    // остальное содержимое конфигурационного класса
}

  Создайте интерфейс UserRepository на основе уже существующей сущности User. Он будет наследовать интерфейс JpaRepository.

public interface UserRepository extends JpaRepository<User, Long> {
}

  Интерфейс JpaRepository использует параметры двух типов.
Первый — класс сущности User, для которой создаётся репозиторий. Второй — Long, тип идентификатора сущности User.
В нашем примере это тип поля id.
  Обратите внимание: магия Spring позволяет использовать интерфейс репозитория для внедрения зависимости.
С помощью аннотации @EnableJpaRepositories и специального класса-регистратора интерфейс Repository и его наследники «становятся» бинами.

                                                  Как это работает

  При запуске приложения создаётся автоматическая реализация интерфейса.
Spring ищет все интерфейсы, унаследованные от Repository, и анализирует, какую сущность JPA итоговый интерфейс использует в виде параметра.
С помощью механизмов Spring эта реализация превращается в уникальный класс-прокси.
Он имплементирует стандартные CRUD-операции для нужного класса-сущности, которые в общем виде реализованы в классе SimpleJpaRepository.
  Теперь все остальные компоненты, работающие с этим репозиторием, смогут запрашивать данные пользователей через автоматическую имплементацию.
Больше не нужно писать практически одинаковые SQL-запросы и мапперы для каждой сущности и вручную отмечать репозиторий аннотацией @Component.
Всё происходит автоматически на старте приложения.
  У такой автоматизации есть как плюсы, так и минусы. Минус в том, что нельзя поправить запрос в автоматически сгенерированном методе.
Зато если разработчику не нравится сгенерированный запрос, он может написать свой — и это будет быстрее и удобнее, чем при работе с JDBC.
Для отладки предусмотрен способ, который позволяет увидеть сгенерированные в репозиториях и ORM-фреймворках запросы.
Достаточно добавить в файл настроек приложения application.properties параметр hibernate.show_sql=true.


                                        JpaRepository: методы и возможности

Рассмотрим иерархию наследования UserRepository.

Разберём некоторые из методов:

    save — метод, объединяющий в себе операции Create и Update. Позволяет сохранить как одну, так и сразу несколько сущностей.
    count() — позволяет узнать общее количество строк в таблице.
    getById(ID) и findById(ID) — позволяют найти в базе данных сущность по её идентификатору. Реализуют операцию Read.
    delete(ID) — реализует операцию удаления сущности Delete.
    findAll() — позволяет запросить все сущности в таблице.

https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.definition

==============================================================================================================================================

  Авторы Spring Data дополнили интерфейс JpaRepository полезным методом findAll(Pageable).
Это метод для постраничной загрузки данных из таблицы с одновременной сортировкой.
  Допустим, в таблице миллион пользователей. Если мы захотим отобразить их список,
придётся загрузить миллион строк и преобразовать данные в миллион объектов.
Затем нужно будет вывести миллион записей пользователю программы, который обычно видит на экране не больше 30–50 строк.
Это неэффективный способ получения данных.

  Рассмотрим способ с применением метода findAll(Pageable).
В этом способе используются автоматическая имплементация интерфейса PagingAndSortingRepository и сгенерированных запросов SQL,
а также объект Pageable и специальные параметры offset, limit, sort и count для классов Page и Sort.


@Service
public class UserServiceImpl implements UserService {
    private final UserRepository repository;

    public UserServiceImpl(UserRepository repository) {
        this.repository = repository;
    }

    public void checkUsers(){
                // сначала создаём описание сортировки по полю id
        Sort sortById = Sort.by(Sort.Direction.ASC, "id");
                // затем создаём описание первой "страницы" размером 32 элемента
        Pageable page = PageRequest.of(0, 32, sortById);
        do {
                        // запрашиваем у базы данных страницу с данными
            Page<User> userPage = repository.findAll(page);
                        // результат запроса получаем с помощью метода getContent()
            userPage.getContent().forEach(user -> {
                // проверяем пользователей
            });
                        // для типа Page проверяем, существует ли следующая страница
            if(userPage.hasNext()){
                                // если следующая страница существует, создаём её описание, чтобы запросить на следующей итерации цикла
                page = PageRequest.of(userPage.getNumber() + 1, userPage.getSize(), userPage.getSort()); // или для простоты -- userPage.nextOrLastPageable()
            } else {
                page = null;
            }
        } while (page != null);
    }
}
