- volatile      - Изменение volatile переменной сразу видны всем потокам. Это одно из решений проблемы видимости
                  (если новые значения вычисляются, а не просто присваиваются, возможна ошибка "потерянный апдейт" !!!)
                  стоит применять когда только один поток изменяет значение, а остальные только читают !!!

volatile int statusCode = 4;

------------------------------------------------------------------------------------------------------------------------

- synchronized  - слово synchronized гарантирует, что только один поток может зайти в обозначенный участок кода

private Object lock = new Object();  // объявляем объект синхронизации

public void smth() {
   synchronized (lock) {             // синхронизируемся по объекту lock
      // критическая секция, сюда может зайти только один поток
   }
}

public synchronized int getSize() {…} // можно добавить synchronized в сигнатуру метода

========================================================================================================================

class MyThread extends Tread {
  public void run ();
}

MyThread myThread = new MyThread();
myThread.start();

------------------------------------------------------------------------------------------------------------------------

            Thread thread = new Thread(() -> System.out.println("Start MultiThreading !!!"));

- thread.start();                           - старт потока
- thread.setName("Some_name");              - задать имя потоку
- thread.getName();                         - узнать имя потока
- thread.setDaemon(true);                   - поток станет фоновым (по умолчанию false)
                                              Разница: пока в JVM есть хотя бы один обычный поток, JVM продолжает работу.
- thread.setPriority(Thread.MAX_PRIORITY);  - установить приоритет потока (не даёт гарантий !!!)
- thread.join();                            - ожидание завершения потока
- thread.stop();                            - жёсткое прерывание потока (НЕ РЕКОМЕНДУЕТСЯ !!!)
- thread.interrupt();                       - нормальное остановка, но требует обработки
                                  if (thread.isInterrupted()) {
                                      close();
                                      throw new SocketException("Closed by interrupt");
                                  }
- thread.getState();                        - получить состояние потока (NEW, RUNNABLE или TERMINATED)
                                             (возможно TIMED_WAITING - если sleep())
- Thread.sleep(1000)                        - остановить выполнение потока на 1 секунду

Экзекьютор - это верхнеуровневая структура, которая скрывает за собой готовый набор потоков (пул потоков) и очередь задач.

Задачи из очереди распределяются по свободным потокам. При завершении задачи поток возвращается обратно в пул.