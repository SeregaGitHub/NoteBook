SELECT sp.advertising_id,
       sp.install_date,
       sp.session_num,
       sp.payer,
       sp.last_active AS last_date,
       DATE_DIFF(sp.last_active, install_date, DAY) AS max_play
FROM players AS sp
WHERE sp.date = '2021-02-28'
  AND sp.install_date BETWEEN '2021-02-01' AND '2021-02-26';
---------------------------------------------------------------------------------------

ROUND ((SUM (total)) / COUNT (DISTINCT (customer_id)))  --  средняя выручка на уникального покупателя, округлённая до ближайшего целого числа

---------------------------------------------------------------------------------------

                                      Группировка по нескольким полям

  Покажем на примере: нужно сравнить количество заказов по дням, а также учесть, в какой стране был сделан заказ.
В этом случае можно сгруппировать данные по двум полям сразу: invoice_date и billing_country.
  Напомним, что если поле invoice_date хранит данные типа varchar лучше сразу преобразовать в тип date.
Для этого в запросе используется оператор CAST.
Таблица будет отсортирована по убыванию значений в поле invoice_date.

SELECT CAST(invoice_date AS date),
       billing_country,
       COUNT(total)
FROM invoice
GROUP BY CAST(invoice_date AS date),
         billing_country
ORDER BY CAST(invoice_date AS date) DESC
LIMIT 5;

invoice_date	billing_country	count
2013-12-22	India	1
2013-12-14	Finland	1
2013-12-09	Portugal	1
2013-12-06	Canada	1
2013-12-05	USA	1

  Понять, что с чем группируется, может быть сложно.
Сначала сравните прошлую таблицу с результатом запроса с ключевым словом DISTINCT:

SELECT DISTINCT CAST(invoice_date AS date),
       billing_country
FROM invoice
ORDER BY CAST(invoice_date AS date) DESC
LIMIT 10;

invoice_date	billing_country
2013-12-22	India
2013-12-14	Finland
2013-12-09	Portugal
2013-12-06	Canada
2013-12-05	USA

  С помощью ключевого слова DISTINCT можно получить похожую выдачу, но без поля с результатом агрегирующей функции COUNT,
ведь применить её вместе с DISTINCT не получится. В остальном две таблицы похожи,
потому что оператор GROUP BY собрал группы из всех уникальных комбинаций в полях invoice_date и billing_country.

---------------------------------------------------------------------------------------

                                      Сортировка по нескольким полям

  Сортировка по нескольким полям устроена сложнее, чем группировка.
При сортировке важен порядок полей, которые указывают после оператора ORDER BY.
В случае с группировкой порядок полей влияет только на их расположение в таблице.

  Сортировать можно не только числа, но и строки: страна заказа будет отсортирована в лексикографическом порядке.
Идентификатор пользователя будет отсортирован по возрастанию, а сумма заказа — по убыванию.

SELECT billing_country,
       customer_id,
       total
FROM invoice
WHERE billing_country = 'India' or billing_country = 'Portugal'
ORDER BY billing_country,
         customer_id,
         total DESC;
---------------------------------------------------------------------------------------

  На сочетании с агрегирующими функциями нужно остановиться отдельно.
Оператором WHERE можно отобрать нужные записи и применить к ним агрегирующую функцию, например SUM.

SELECT SUM(total)
FROM invoice
WHERE total > 5;

  Использовать агрегирующую функцию в условии после оператора WHERE нет смысла,
ведь условие отбирает записи, которые станут аргументом агрегирующей функции.
  В случае с оператором HAVING наоборот — условие должно включать агрегирующие функции, иначе от такого среза будет немного пользы.
Сгруппировав данные по пользователям, можно применить оператор HAVING, чтобы отфильтровать нужные записи.
Результат отсортирован по убыванию суммы выручки.

SELECT customer_id,
       SUM(total)
FROM invoice
GROUP BY customer_id
HAVING SUM(total) > 41
ORDER BY SUM(total) DESC;

---------------------------------------------------------------------------------------

CREATE TABLE films (
        id INTEGER GENERATED BY DEFAULT AS IDENTITY,
        title varchar(40) NOT NULL,
        produced integer NOT NULL,
        date_prod date,
        kind varchar(10),
        len_min integer,
        CONSTRAINT films_pk PRIMARY KEY (id),
        CONSTRAINT constr_example CHECK (len_min > 100 AND title <> '')
);


CREATE TABLE users (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name varchar(40) DEFAULT 'unknown'                              -- если поле пустое -> присвоится значение по умолчанию
);


CREATE TABLE favorite_films (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id INTEGER REFERENCES users (id),
    film_id INTEGER REFERENCES films (id)
);
  Итак, мы создали таблицу favorite_films с любимыми фильмами пользователей.
Записи в ней ссылаются на таблицы users и films, но без указания конкретных столбцов.
В этом случае столбец будет неявно связан с первичным ключом таблицы, на которую он ссылается,
что нам и нужно при создании вторичного ключа.


  А если значение, на которое мы ссылаемся, будет удалено? Например, мы удалили какой-то товар из нашей базы или фильм из примера выше.
Есть несколько вариантов действий в такой ситуации. Самые популярные такие:

-  запретить удаление записи, на которую есть ссылка, — режим RESTRICT (англ. «ограничивать»);
-  удалить все связанные записи — режим CASCADE (англ. «каскад, водопад»).

Задать поведение можно следующим образом:

CREATE TABLE favorite_films (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id INTEGER REFERENCES users (id) ON DELETE RESTRICT,
    film_id INTEGER REFERENCES films (id) ON DELETE CASCADE
);

  Теперь если кто-то попытается удалить пользователя, на которого есть ссылка из таблицы favorite_films, то это действие будет запрещено.
А при удалении фильма все записи, которые ссылаются на него, будут удалены.

Кроме удаления и ограничения, существуют и другие варианты действий:

-  NO ACTION — выдаст ошибку, показывающую, что при удалении или изменении записи произойдёт нарушение ограничения внешнего ключа.
   Ошибка произойдёт в момент проверки ограничения. Этот вариант действия подразумевается по умолчанию.
-  SET NULL и SET DEFAULT — при удалении связанных строк в соответствующие столбцы таблицы, из которой есть ссылка,
   присваиваются значения NULL или значения по умолчанию соответственно.

===========================================================================================================================

ALTER TABLE products ADD CHECK (name <> 'что-то странное');

//имя товара должно быть уникальным
ALTER TABLE products ADD CONSTRAINT uq_products_name UNIQUE (name);

//поле some_id должно быть внешним ключом к таблице another_table
ALTER TABLE example ADD CONSTRAINT fk_example_to_another_table FOREIGN KEY (some_id) REFERENCES another_table;

//теперь категория должна быть указана (не равна NULL)
ALTER TABLE products ALTER COLUMN category SET NOT NULL;

ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;

ALTER TABLE products ALTER COLUMN price SET DEFAULT 100;

ALTER TABLE products ALTER COLUMN price DROP DEFAULT;

ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);

-----------------------------------------------------------------------------------------------------------------------------
ON UPDATE RESTRICT ???

ON DELETE RESTRICT ON UPDATE CASCADE — это что еще такое?

  Таким образом мы определяем поведение поля, которое ссылается на другую таблицу, при изменении соответствующих данных в этой таблице.
ON DELETE RESTRICT означает, что если попробовать удалить пользователя, у которого в таблице заказов есть данные, БД не даст этого сделать.
В данном случае, поскольку это заказы, то есть данные, которые, скорее всего, достаточно важны, я поставил ограничение (RESTRICT).
Если бы я указал ON DELETE CASCADE, БД сама удалила бы все заказы пользователя при его удалении.
Есть еще одна опция — ON DELETE SET NULL. При ее использовании БД запишет NULL в качестве user_id для всех заказов удаленного пользователя.
ON UPDATE CASCADE говорит о том, что в случае если кто-то решит изменить ID пользователя, все его заказы получат новый, измененный ID.
Зачем может понадобиться менять ID — это другой вопрос, операция крайне редкая.
-----------------------------------------------------------------------------------------------------------------------------
