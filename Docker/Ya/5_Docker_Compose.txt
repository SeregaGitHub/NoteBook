
  Секретные ключи, доступы, токены не следует хранить в коде. При этом для работы приложения их всё-таки нужно передать в контейнер.
Это можно сделать несколькими способами:

-    прописать переменные окружения прямо в Dockerfile — для этого есть инструкция ENV: ENV token 12345;
-    задать переменные окружения при сборке контейнера, выполнив команду run с ключом -e: docker run <IMAGE-NAME> -e token=12345;
-    сохранить переменные окружения в настроечном файле Docker Compose — мы будем использовать именно этот способ как наиболее гибкий и удобный.

Измените файл application.properties, чтобы значения загружались из переменных окружения.

...
jdbc.url=jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_NAME}
jdbc.username=${POSTGRES_USER}
jdbc.password=${POSTGRES_PASSWORD}
...-

  Не забудьте пересобрать проект с помощью mvn clean package. Также убедитесь, что в файле pom.xml присутствует соответствующий плагин.

                                                      Пишем Dockerfile

  Как и раньше, добавьте в Dockerfile инструкцию по запуску jar-файла.

FROM amazoncorretto:11-alpine-jdk
COPY target/*.jar app.jar
ENTRYPOINT ["java","-jar","/app.jar"]


                                        Описываем контейнеры в docker-compose.yaml

  Инструкции по развёртыванию проекта в нескольких контейнерах пишут в файле docker-compose.yaml.
Создайте этот файл в корневой директории проекта.
  Структура будет следующая:

Корневая папка проекта
├── src
│    ├── main
│    │   ├── java
│    │   │   └── # файлы приложения
│    │   └── resources
│    │   │   ├── appliaction.properties
│    │   │   ├── logback.xml
│    │   │   └── schema.sql
│    └── test
├── # возможно, ещё файлы в вашем проекте
├── .gitignore
├── Dockerfile  <-- Dockerfile
├── docker-compose.yaml <-- новый Docker Compose файл
└── pom.xml


        Добавьте в docker-compose.yaml эти инструкции:

# версия Docker Compose
version: '3.8'

# имена и описания контейнеров, которые должны быть развёрнуты
services:
  # описание контейнера db
  db:
    # образ, из которого должен быть запущен контейнер
    image: postgres:13.7-alpine
    # volume и связанная с ним директория в контейнере
    volumes:
      - /var/lib/postgresql/data/
    # переменные окружения
    environment:
      - POSTGRES_DB=later
      - POSTGRES_USER=root
      - POSTGRES_PASSWORD=root

  web:
    build: .
    ports:
      - "8080:8080"
    # "зависит от",
    depends_on:
      - db
    # переменные окружения
    environment:
      - DB_NAME=later
      - POSTGRES_USER=root
      - POSTGRES_PASSWORD=root
      - DB_HOST=db
      - DB_PORT=5432

===============================================================================================================================

                                                    Разберём подробнее:

    version — версия Docker Compose. 
    
    От версии зависит набор команд, которые можно применять в docker-compose.yaml. 
В свою очередь, версия Docker Compose зависит от версии Docker. Версию Docker можно узнать с помощью следующей команды.

$ docker --version 

Подробности о зависимости версий Docker Compose и Docker можно найти в документации:

https://docs.docker.com/compose/compose-file/compose-versioning/

volumes — имя директории для хранения данных.

--------------------------------------------------------------------------------------------------------------------------------------------------

  Если томов несколько, то достаточно перечислить их имена. 
После имён остаются двоеточия, потому что для каждого тома могут быть указаны дополнительные параметры 
подробнее об этом в документации:
https://docs.docker.com/storage/volumes/


version: '3.8'

services:
  ...

volumes:
  volume-first-name:
  volume-second-name: 

В нашем примере том всего один, поэтому данный пункт можно пропустить — тогда будет использоваться том по умолчанию

--------------------------------------------------------------------------------------------------------------------------------------------------

    services — список имён и описаний контейнеров, которые должны быть развёрнуты. 
      В листинге описаны два контейнера: db (для базы данных) и web (для самого сервиса).

    Важно: имена этих контейнеров могут быть любые, в нашем примере они отражают предназначение контейнера.

В описании контейнера объявляются:

    image — сообщает, из какого образа создавать контейнер (как в описании контейнера db).

    volumes — указывает, из какой директории контейнера нужно переносить данные в volume — внешнее хранилище данных. 

    Таких хранилищ может быть несколько, поэтому здесь же указывается и в какое именно хранилище должны переноситься данные.

     Названия хранилищ указываются через двоеточие. 
     Например, строка volume-first-name:/home/node/app говорит, что из директории /home/node/app данные необходимо сохранить в том volume-first-name. 
     Если используется только один том, то название не указывается. Указывается только директория, откуда в volume сохраняются данные, — как в нашем примере.

    environment — описывает переменные для каждого из контейнеров. Так, переменными окружения для PostgreSQL описываются настройки создаваемой БД. 
    Подробнее — в документации к образу.
    https://hub.docker.com/_/postgres

    build <address> — создать образ для контейнера из Dockerfile, который лежит в директории <address> (как в описании контейнера web).

    ports — указывает, какие порты открыть наружу и какие порты приложения им соответствуют (это называют «проброс портов»).

    depends_on — определяет, после какого контейнера должен быть запущен описываемый контейнер. 
    В нашем примере указано, что контейнер web запустится после контейнера db.

Теперь запустите Docker Compose командой docker-compose up.

Во время работы контейнеров в терминале ведётся лог, поэтому выполнить из этого же терминала команду остановки контейнеров невозможно. 
Придётся открыть второй терминал, перейти в папку с проектом и только тогда выполнить docker-compose stop. 
От лишних действий избавит сочетание клавиш Ctrl+C: этой командой можно остановить контейнеры прямо из консоли с логом.