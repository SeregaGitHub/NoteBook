
                                            Четыре характеристики транзакций

  Для обозначения четырёх характеристик транзакций используется аббревиатура ACID.
Каждая транзакция должна обладать следующими характеристиками:

-   Атомарность (англ. Atomicity) — все операции транзакции выполняются атомарно, то есть целиком.
  Если выполнены лишь некоторые инструкции, транзакция считается неуспешной и полностью откатывается (англ. rollback).
  Если все инструкции выполнены корректно, транзакция рассматривается как завершённая, и её результаты фиксируются в БД.

-   Согласованность (англ. Consistency) — транзакция переводит базу данных из одного согласованного состояния в другое.
  Например, если средства списываются с одного счёта, они обязательно должны зачислиться на другой.
  База должна быть в согласованном состоянии по окончании каждой транзакции — все правила и ограничения выполняются.
  У пользователей нет доступа к несогласованным данным.

-   Изолированность (англ. Isolation) — каждая транзакция выполняется сама по себе, без взаимодействия с другими.
  Ни одна транзакция не работает с изменениями, вносимыми другой, пока та не будет завершена.
  Например, если одна транзакция началась и работает со счетами Софии и Тимофея, другая не может обратиться к этим счетам и изменить их.

-   Надёжность (англ. Durability) — по завершении транзакции все внесённые ею изменения фиксируются в БД.
  Даже если по окончании транзакции произойдёт аппаратный или программный сбой, после восстановления эти данные будут в базе.

=================================================================================================================================================

                                                Управление транзакциями в SQL

  Разберём, как управлять созданием и проведением транзакций с помощью языка SQL.
Команда BEGIN начинает блок транзакции. Все операторы после этой команды и до команды COMMIT или ROLLBACK будут выполняться в одной транзакции.
Команда COMMIT фиксирует текущую транзакцию: все выполненные ею изменения становятся видимыми для других и гарантированно сохранятся в случае сбоя.
При попытке выполнить COMMIT вне транзакции ничего не произойдёт.

  Синтаксис для выполнения транзакции из нашего примера выглядит так:
-------------------------------------------------------------------------------------------------------------------------------------------------
BEGIN; -- шаг 1: начинаем транзакцию

UPDATE accounts SET balance = balance - 100.00 WHERE name = 'София';
UPDATE bank_balance SET balance = balance - 100.00 WHERE name = (SELECT bank_name FROM accounts WHERE name = 'София'); -- шаг 2: списываем средства со счёта Софии

UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Тимофей';
UPDATE bank_balance SET balance = balance + 100.00 WHERE name = (SELECT bank_name FROM accounts WHERE name = 'Тимофей'); -- шаг 3: зачисляем средства на счёт Тимофея

COMMIT; -- шаг 4: завершаем транзакцию
-------------------------------------------------------------------------------------------------------------------------------------------------

  С помощью команды ROLLBACK можно откатить текущую транзакцию. Это приведёт к отмене всех произведённых ею изменений. Синтаксис следующий:

-------------------------------------------------------------------------------------------------------------------------------------------------
BEGIN; -- шаг 1: начинаем транзакцию

UPDATE accounts SET balance = balance - 99.99 WHERE name = 'София'; -- шаг 2: списываем средства со счёта Софии

ROLLBACK; -- шаг 3: упс! Что-то пошло не так: не та сумма. Отменяем транзакцию
-------------------------------------------------------------------------------------------------------------------------------------------------

                                                    Транзакции в Java

  Используем JDBC и методы для управления транзакциями.

import java.sql.Connection;

public class SimpleTransactionalDAO {

    public void doInTransaction(){
        Connection connection = dataSource.getConnection();

        connection.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);

        try (connection) {
          connection.setAutoCommit(false);

          // выполнение SQL-запросов для перевода средств
          // со счёта Софии на счёт Тимофея

          connection.commit();
        } catch (SQLException e) {
          connection.rollback();
        }
    }
}

=================================================================================================================================================

                                                  Настраиваем приложение

  Разберём, как подготовить Spring-приложение к работе с транзакциями. Сначала необходимо добавить в код бин типа JpaTransactionManager.
Сделать это можно с помощью метода, аннотированного @Bean.

@Bean
public JpaTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {
    JpaTransactionManager transactionManager = new JpaTransactionManager();
    transactionManager.setEntityManagerFactory(entityManagerFactory);
    return transactionManager;
}

  Эту настройку мы упоминали в теме о Spring Data JPA. С её помощью стандартный менеджер транзакций подключается к менеджеру сущностей.
Также существуют альтернативные реализации менеджера транзакций. Например, такие, которые позволяют работать с распределёнными транзакциями.
Или такие, которые работают с предоставляемыми конкретными БД настройками.
Есть менеджер, который не управляет транзакциями напрямую и используется для отладки кода приложения.
  Второй и последний шаг — подключение механизма транзакционности для Spring в целом.
Для этого пометьте конфигурационный класс в вашем приложении Later аннотацией @EnableTransactionManagement.

@Configuration
@EnableTransactionManagement // включает управление транзакциями и обработку соответствующих аннотаций
@EnableJpaRepositories(basePackages = "ru.practicum")
public class PersistenceConfig{
    // здесь остальные настройки
}

Готово! Теперь поддержка транзакций будет активна при запуске приложения.

=================================================================================================================================================

                                                    Пишем транзакционный метод

  Методы, в которых используются транзакции, называют транзакционными (англ. transactional).
Рассмотрим самый простой метод, взаимодействующий с базой данных, — например, UserServiceImpl.getAllUsers().
Он получает список всех пользователей.
Чтобы метод стал транзакционным, отметьте его аннотацией @Transactional.

@Transactional
@Override
public List<UserDto> getAllUsers() {
    return repository.findAll()
            .stream()
            .map(UserDto::from)
            .collect(Collectors.toList());
}

  Теперь Spring поймёт, что метод — транзакционный, и при создании бинов автоматически обернёт его скрытым кодом.
Такой код обеспечивает алгоритм работы транзакционных методов — в том числе отлов ошибок и автоматическое завершение или отмену транзакции.
Если в процессе работы метода возникло исключение, которое не было перехвачено в теле метода, транзакция будет отменена.

  Обратите внимание: запрос к базе данных в этом методе работает только на чтение — то есть получает информацию, но не изменяет её.
Чтобы оптимизировать выполнение таких запросов, можно поменять настройки транзакции в SQL и задать режим доступа «только чтение».
Реализуйте эту настройку через аннотацию @Transactional. Для этого используйте параметр readOnly = true.

@Transactional(readOnly = true)
@Override
public List<UserDto> getAllUsers() {
    return repository.findAll()
            .stream()
            .map(UserDto::from)
            .collect(Collectors.toList());
}

  Через конфигурацию транзакционного метода можно гибко настраивать и использовать возможности SQL и Spring.
Можно, например, настроить уровень изоляции транзакции (об уровнях расскажем в следующем уроке) или указать конкретные классы исключений,
на которые будет реагировать обработчик отката транзакций. Почитайте подробнее об этих возможностях в документации.

https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html
