
                                                Типы выборки сущностей в JPA

Выборка связанных данных может быть двух типов:

-    EAGER (немедленная выборка) — означает, что связанные данные будут выгружены одновременно с основной сущностью;
-    LAZY (отложенная выборка) — означает, что связанные данные будут выгружены только тогда, когда они понадобятся.
   То есть когда в коде будет обращение к полю, которое ссылается на связанную сущность (или на коллекцию связанных сущностей).

-    Тип выборки LAZY в JPA включён по умолчанию для следующих аннотаций: @ElementCollection, @ManyToMany и @OneToMany.
-    У аннотаций @ManyToOne и @OneToOne по умолчанию используется EAGER.

  Рекомендуем использовать режим отложенной выборки LAZY для всех видов связей.
Это позволит существенно снизить нагрузку на базу данных и увеличить производительность приложения — ведь данные будут выгружаться только тогда, когда они требуются.
  Вам может понадобиться изменить режим немедленной выгрузки на отложенный.
В этом уроке мы будем показывать все действия на примере сервиса для публикации постов (как в социальной сети).
Вот так можно изменить режим выборки у связи поста и его автора.

@Entity
@Table(name = "posts")
public class Post {
    // ...

    // меняем тип выборки с немедленного (EAGER) на отложенный (LAZY)
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "author_id", nullable = false)
    private User author;

    // ...
}

  В процессе разработки и отладки кода, который работает с БД, можно контролировать содержимое и количество генерируемых ORM запросов.
В этом помогут логи, которые пишет Hibernate. Чтобы отобразить нужные записи логов, следует добавить в application.properties настройки для логгеров Hibernate.

# вывод запросов
logging.level.org.hibernate.SQL=DEBUG
# вывод значений, которые подставляются в параметры запросов
logging.level.org.hibernate.type.descriptor.sql.BasicBinder = TRACE

======================================================================================================================================================================

                                              Проблема N+1 запросов

  Допустим, нужно выгрузить краткую информацию обо всех постах в приложении.
Информация должна содержать идентификатор поста, его заголовок, а также имя автора.

// выгружаем все посты
return postService.findAllPosts()
        .stream()
        .map(post -> {
            // для каждого поста получаем имя его автора
            String authorName = post.getAuthor().getName();
            // формируем нужную информацию
            return PostShortDto.of(post.getId(), post.getTitle(), authorName);
        })
        .collect(Collectors.toList());

  Такой код выполняет поставленную задачу. Но если для связи поста и автора указан отложенный тип выборки (LAZY),
это приведёт к N+1 запросу, где N — количество постов.


                                                Выражение JOIN FETCH

  Выражение JOIN FETCH применяется при написании JPQL-запросов и гарантирует немедленную выборку данных:

public interface PostRepository extends JpaRepository<Post, Long> {
    @Query(" select p " +
            "from Post p " +
            "JOIN FETCH p.author")  // JOIN FETCH гарантирует немедленную выборку
    List<Post> findAllWithAuthors();
}

  Определённый таким образом метод findAllWithAuthors динамически меняет режим выборки на EAGER.

  Есть ещё одно преимущество JOIN FETCH. Нужные сущности (авторы) будут выгружаться не дополнительным (вторым) запросом,
а вместе с основными объектами (постами) — в одном запросе с использованием внутреннего соединения (inner join).

  Динамически можно изменить только отложенный тип выборки (LAZY). Если в описании сущности для связи указать немедленный тип выборки (EAGER),
то переопределить его динамически не получится.

  Общее правило работы со связанными сущностями:

  Для всех связей рекомендуется выбирать режим отложенной выборки FetchType.LAZY.
Он позволит избежать выгрузки лишних данных, когда они не требуются.
Если связанные сущности нужно выгружать сразу, используйте отдельные методы, определённые с помощью JPQL и выражения JOIN FETCH.

======================================================================================================================================================================

  Допустим, нужно выгрузить две сущности. При этом ORM в проекте не используется, а соединение с базой данных происходит напрямую через JDBC.
Пусть это будут посты и их комментарии — сущности Post и Comment. К решению задачи можно подойти так.

@GetMapping
public Collection<PostWithCommentsDto> getPosts() {
    // выгружаем посты (один запрос)
    Map<Long, Post> postMap = postService.findAllPostsWithAuthors()
            .stream()
            .collect(Collectors.toMap(Post::getId, Function.identity()));
    // выгружаем комментарии (ещё один запрос)
    Map<Long, List<Comment>> commentMap = commentService.getByPostId(postMap.keySet())
            .stream()
            .collect(Collectors.groupingBy(Comment::getPostId));
    // готовим окончательный результат из полученных данных (нет обращений к БД)
    return postMap.values()
            .stream()
            .map(post -> makePostWithCommentsDto(
                    post,
                    commentMap.getOrDefault(post.getId(), Collections.emptyList())
            ))
            .collect(Collectors.toList());
}

private PostWithCommentsDto makePostWithCommentsDto(Post post, List<Comment> comments) {
    // конвертируем комментарии в DTO
    List<CommentDto> commentDtos = comments
            .stream()
            .map(comment -> CommentDto.of(comment.getId(), comment.getText(), comment.getPostId()))
            .collect(Collectors.toList());
    // формируем окончательное представление для данного поста
    User author = post.getAuthor();

    return PostWithCommentsDto.of(
            post.getId(), post.getTitle(), post.getText(),
            UserDto.of(author.getId(), author.getName(), author.getEmail()),
            commentDtos
    );
}

======================================================================================================================================================================

  Если нужно указать с какого индекса начать и какое количество вернуть:

Чтобы создать правильный запрос пагинации, используйте следующее выражение: PageRequest.of(from > 0 ? from / size : 0, size).
