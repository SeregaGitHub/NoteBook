
                                                  Запросные методы и механизм проекций

  Механизм репозиториев — основной механизм работы с хранилищами в Spring. Поэтому в этой теме расскажем о репозиториях больше.

                                                      От простого к управляемому

  Модуль Spring Data с помощью сгенерированных классов сам формирует реализацию каждого репозитория —
наследника базового интерфейса Repository или его потомков.
Даже простой репозиторий — довольно быстрый и удобный способ подключить к проекту хранилище и сосредоточиться на работе над основными функциями.
Возьмём репозиторий, с которым вы работали ранее.

public interface UserRepository extends JpaRepository<User, Long> {
}

  При всей простоте даже этот репозиторий может выполнять все CRUD-операции и автоматически решает почти все проблемы написания DAO.
Более того, для такого репозитория уже включены транзакции. Плюс поддержка JPA позволяет загружать через репозитории любую сложную сущность.
Однако вместе с ростом проекта растут требования к его хранилищу.
К примеру, из небольшого репозитория легко получить разом пару десятков объектов с помощью метода findAll(),
а вот выбрать конкретные 20 объектов из 17 миллионов легко уже не получится. Нужно учесть, что объекты могут не поместиться в память,
их может быть сложно быстро выгрузить, и другие нюансы. Приходится искать и выбирать более сложные (и одновременно эффективные) способы работы с репозиториями.

                                                          Запросные методы

  Чтобы задать условия выборки из хранилища, можно использовать запросы SQL (с условием WHERE и без), и иногда без них не обойтись.
Но авторы Spring Data предлагают другое решение — объявлять методы по определённым правилам.
Попробуйте перевести с английского языка название такого метода.

List<User> findByEmailContainingIgnoreCase(String emailSearch)

  Название метода содержит следующие смысловые части:

    findBy — найти все объекты, у которых;
    EmailContaining — поле email содержит строку, переданную в качестве параметра;
    IgnoreCase — при этом неважно, в каком регистре будет эта строка.

  Такой метод созвучен следующему запросу.

select * from users where email ilike '%:emailSearch%'

  Для наглядности мы использовали обращение к параметру запроса через двоеточие : и оператор ilike, специфичный для PostgreSQL.
Сходство названия метода и запроса сразу бросается в глаза. Это заметили и программисты из Spring Data.
Благодаря тому, что названия методов поиска по определённым свойствам сущностей почти всегда звучат одинаково,
возникла идея описывать нужные запросы непосредственно с помощью таких методов.
То есть достаточно написать в виде понятной команды название метода и Spring Data преобразует его в запрос.
Эта технология получила название запросные методы (англ. Query Methods).

  Запросные методы добавляются непосредственно в репозиторий. То есть в интерфейсе репозитория объявляется метод (без реализации),
название которого складывается из специальных слов и названий полей сущности.
Количество и порядок записи параметров метода при этом должны совпадать с теми запросными выражениями, которые вы использовали в названии метода.
К слову, многие IDE уже умеют подсказывать правильные параметры.

package ru.practicum.user;

import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

interface UserRepository extends JpaRepository<User, Long> {
    List<User> findByEmailContainingIgnoreCase(String emailSearch);
}

  Помимо поиска по одному из полей сущности есть возможность составлять логические выражения с помощью слов And и Or,
а также словосочетаний LessThan, Between, Containing и других.
Результат может быть оформлен в виде списка или единичной сущности (Optional поддерживается).

Optional<Item> findByUserIdAndUrl(long userId, String url)

Подробнее о запросных методах и правилах, как их создавать, рассказывается в документации

https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation

=====================================================================================================================================================

                                                  Проекция под нужным углом

  Результатом запросных методов может быть сущность или список сущностей. В большинстве случаев этого достаточно, но не всегда.
Представьте, сущность пользователя (User) хранится в таблице, в которой 40 колонок. При этом нужно вывести только часть информации.
Например, показать имя рядом с почтовым адресом. К примеру, простой SQL-запрос выглядит так.

select * from users where email ilike '%:emailSearch%'

  В случае, когда нужна только часть информации, запрос требуется модифицировать. Нужные колонки указываются в секции select через запятую.
В нашем случае это колонки first_name и email.

select first_name, email from users where email ilike '%:emailSearch%'

  Теперь вы получите значение только двух нужных полей.

  Для получения ограниченной информации из репозитория через запросные методы нужно задействовать механизм проекций.
Он предполагает создание интерфейса-проекции, соответствующего той сущности, поля которой нужно получить в результате запроса.
Доступ к этим полям обеспечивается через методы-геттеры.
К примеру, добавим интерфейс-проекцию для сущности User для доступа к полям first_name и email.

package ru.practicum.user;

public interface UserShort {
    String getFirstName();
    String getEmail();
}

  Геттеры исходной сущности и проекции должны совпадать. Только в этом случае репозиторий правильно распознает запрос.
Интерфейс-проекция при этом указывается в качестве типа результата в запросном методе.

List<UserShort> find**All**ByEmailContainingIgnoreCase(String emailSearch);

  Теперь при запросе объём получаемых данных будет уменьшен до полей, указанных в проекции нужной сущности.
Этот механизм можно использовать, чтобы скрыть секретные поля с паролями, суммами на счёте и прочей чувствительной информацией.

https://www.baeldung.com/spring-data-jpa-projections
