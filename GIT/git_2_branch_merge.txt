
                          ВЕТКИ
- git branch                            -  просмотр веток
- git branch -v                         -  просмотр веток с инф. о коммите
- git branch названиеВетки              -  создание новой ветки
- git checkout названиеВетки            -  переключение веток
- git checkout @{-1} (можно -2 и т.д.)  -  переключение на предыдущую ветку
- git checkout -b названиеВетки         -  создание ветки и
                                           переключение на неё.
   (если в предыдущей ветке были незакиммиченные изменения,
      то они автоматически ПЕРЕДУТ в новую ветку !!!)

- git checkout -f master  -  переключение на ветку
       master, БЕЗ сохранения изменений на предыдущей
- git checkout -f HEAD  -  удаление ВСЕХ изменений
                           в текущей ветке до коммита

------------------------------------------------------------------------------------------------------

                                        STASH

- git stash                  -  сохраняет изменения в файле НЕ коммитя их
- git stash apply            -  возвращает изменения
- git stash pop              -  возвращает изменения и удаляет их списка
- git stash list             -  просмотреть список неподтверждённых изменений
- git stash apply stash@{n}  -  вернуть конкретные изменения, n - номер из списка отложенных изменений
- git stash clear            -  удаляет весь список изменений
- git stash drop             -  удаляет только последнее припрятывание
- git stash drop stash@{1}   -  удаляет припрятывание с идентификатором stash@{1}

- git stash save "описание"
- git diff > changes.patch   - способ сохранять изменения в *.patch-файл
- git apply changes.patch    - применить правки, сохранённые в файл changes.patch

------------------------------------------------------------------------------------------------------
- git branch --move bad-branch-name corrected-branch-name  -  изменение названия ветки (локально)
- git push --set-upstream origin corrected-branch-name     -  отправить ветку в удалённый репозиторий
                                                           -  старая ветка всё ещё по-прежнему там
- git push origin --delete bad-branch-name                 -  удаление старой ветки в удалённом репозитории
------------------------------------------------------------------------------------------------------

*************************************************************
     - fix
4594 - master             4594 - fix
2fad                      2fad - fix
54a4                54a4 - master
1913                1913 -------------9e28(если HEAD отделён)
c3ef                c3ef

   Если нужно вернуть master назад, то создаём ветку fix и:
- git branch -f master 54a4
         ИЛИ
- git checkout -B master 54a4
   Так же можно передвигать master и вверх !!!
- git checkout 1913  -  HEAD перейдёт на 1913 коммит
                       (состояние отделённой HEAD)
            Если сделать коммит (например: 9e28)
          в состоянии отделённой HEAD, он будет ПОДВИСШИЙ
- git branch названиеВетки 9e28  -  создаст новую ветку
- git cherry-pick 9e28  -  создаст коммит на текущей ветке
- git checkout 1913 fileName  -  достанет коммит для изменений
                                 (переведёт в индекс и раб дир.)
- git checkout HEAD fileName  -  достанет коммит для изменений
                                 в нём (переведёт в индекс)

*************************************************************
       - branchName  - branchName  - master  - master
      -                master      -         -
master               -             -         - ----branchName_2
  -                  -             -         -       (2c11)
  -                  -             -         -
- git checkout master
  git merge branchName  -  master передвинется на branchName,
                           т.е. объединит ветки.
                           (слияние веток "перемоткой")
  (или git checkout -B master branchName)
- git branch -f master ORIG_HEAD  -  вернёт master обратно
  git checkout master  -  перейти на master обратно
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        Вместо слияния перемоткой ЛУЧШЕ выполнять,
            принудительно, истинное слияние

  git merge --no-ff branchName  -  флаг --no-ff

  git merge branch --ff         -  флаг --ff   -  наоборот, принудительное слияние перемоткой 

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
- git branch -d branchName  -  удалит ветку branchName,
                               если она объединена с master.
- git branch -D branchName_2  -  ПОЛНОСТЬЮ удалит ветку branchName,
                                 инф. будет более недоступна !!!
- git branch branchName_2 2c11  -  вернёт ветку branchName_2,
                                   если удаление было недавно

cat ./git/logs           -  рефлоги гита
cat ./git/logs HEAD      -  рефлоги HEAD

- git reflog             - рефлоги HEAD
- git reflog --date=iso  - рефлоги HEAD с датой
- git reflog master      - рефлоги master

                    Восстановление ветки branchName
    git reflog  -
    6f67d88 HEAD@{3}: checkout: moving from branchName to master
    9d94d40 HEAD@{4}: commit: Вложенные классы
    git branch branchName HEAD@{3}
                 ИЛИ
    git branch branchName HEAD@{дата из, git reflog --date=iso, в ''}
-------------------------------------------------------------------------
                Истинное слияние

                              4594 - master  (ours)-текущая
                              2fad
(theirs)  branchName - 2c11    -
                       2702    -
                        -      -
                           -   -
                               -
                              54a4  (base)

git status        (лучше чтобы статус был чистый !!!)
git merge-base master someBranch  -  покажет идентификатор коммита
                                     на котором разделились эти ветки
git merge branchName              -  запустит слияние веток
(нужно находиться на (текущей)ветке к которой пойдут изменения, сейчас это master)
cat ./git/MERGE_HEAD              -  тут гит запомнит коммит в котором
                                     происходит слияние
                                     в данном случае - 2c11
git reset --hard @~               -  отмена слияния,
                                     после создания общего коммита,
                                     HEAD отойдёт на изначальный master
                                     (Если слияние произошло только в вашем локальном репозитории !!!
                                     И после него не было коммитов !!!)
---------------------------------------------------------------------------------
    Если нужно произвести слияние, но без истории коммитов второй ветки

   newMaster             -  в коммите newMaster будут изменения branchName,
      -                     но не будет её коммитов
           - branchName
          -
    master
      -
      -

  git merge --squash branchName    -  произведёт слияние без коммитов
                                      в ветку master (без логов branchName)
    (Если конфликт - то исправляем, как обычно)

                            Последовательность действий:

  git checkout master
  git merge --squash feature123
  git commit -m 'merged feature #123'
---------------------------------------------------------------------------------

---------------------------------------------------------------------------------

     ЕСЛИ СУЩЕСТВУЕТ КОНФЛИКТ:
  (состояние прерванного слияния)

<<<<<<<< HEAD
    someTekst_1
========
    someTekst_2
>>>>>>>> branchName

git checkout --ours fileName    -  эта команда оставит те изменения,
                                   которые находятся на текущей ветке
                                   (в данном случае на master)
git checkout --theirs fileName  -  эта оставит изменения branchName
git checkout --merge fileName   -  заново покажет исходный конфликт
git checkout --conflict=diff3 --merge fileName
                                -  покажет, что было на месте конфликта в base
git reset --hard                -  отмена слияния
git reset --merge               -  оставляет незакоммиченные изменения
 (git merge --abort)               в файлах, которые не учавствовали в слиянии
                                   то есть которые в обоих ветках одинаковые
    После исправления конфликта:
1) git add
2) git merge --continue (или commit)

3) git log --oneline --all --graph    -  графический лог слияния
4) git show                           -  выведет diff слияния, который
                                         покажет только изменения конфликтов
5) git show --first-parent            -  покажет только изменения родителя
        ЛУЧШЕ
   git diff HEAD^1                    -  покажет только изменения
                                         первого родителя
   git diff HEAD^^                    -  (то же с шагом на предыдущий коммит)
   git diff HEAD^2                    -  покажет только изменения
                                         второго родителя
   git diff HEAD^2^                   -  (то же с шагом на предыдущий коммит)
---------------------------------------------------------------------------
          Если есть конфликты не по строкам, а по смыслу
  (например: изменили метод, а в другой ветке ещё вызывается старый)
               GIT произвёл слияние, но это надо отменить
                    Это Семантический конфликт !!!

1) git reset --hard @~                -  удалит коммит слияния
2) git merge branchName --no-commit   -  слияние веток, но без коммита
                                        (состояние прерванного слияния)
3) Совершаем необходимые изменения
4) git add
5) git merge --continue (или commit)  -  делаем коммит слияния
----------------------------------------------------------------------------
  git branch --merged                 -  покажет все ветки, учавствовавшие
                                         в слиянии
  git branch --no-merged              -  покажет все ветки, НЕ учавствовавшие
                                         в слиянии
  git log master                      -  покажет все коммиты ОБОИХ слитых веток
  git log master --first-parent       -  покажет коммиты ТОЛЬКО изначально
                                         принадлежавшие master
(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
        Можно потом доработать ветку branchName                     veryNewMaster
1) git checkout branchName                                       -       -
2) Произвести доработку, закоммитить                                     -
3) git checkout master                                     -         newMaster
4) Произвести слияние                                newBranchName
          ---
   Если: git merge --log=5    -  в новый коммит добавятся описания 5 коммитов
                                 ветки branchName
)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
