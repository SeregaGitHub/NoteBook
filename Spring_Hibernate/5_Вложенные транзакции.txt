
                                              Работаем с вложенными транзакциями

  Мы рассмотрели один из простых случаев — когда аннотацией @Transactional помечается метод бина-сервиса.
Также ею можно пометить метод бина-контроллера или класс целиком. Поведение программы во всех этих случаях не будет отличаться,
если транзакционные методы используются последовательно и не вызывают друг друга.
  Но может быть и так, например, что транзакционный метод контроллера UserController вызывает транзакционный метод сервиса UserServiceImpl внутри себя.
В этом случае Spring не поймёт, как оформить такой код — как две транзакции или как одну.
С точки зрения Spring, такие «транзакции внутри транзакций» считаются вложенными (англ. nested). С точки зрения БД, вложенных транзакций не существует,
а проблемы, возникающие с их использованием, должен решать код приложения.
Это делается с помощью доступных механизмов управления транзакциями, о которых мы рассказали в прошлом уроке.

  Чтобы поработать с вложенными транзакциями, добавьте в аннотацию @Transactional параметр propagation (англ. «распространение»).

@Transactional(@Transactional(propagation = Propagation.REQUIRED)
public void updateUsers(){
    // код метода
}

Параметр propagation может принимать следующие значения:

-   REQUIRED (англ. «необходимая») — это значение по умолчанию для аннотации. Если транзакции не существует, Spring создаст новую.
  Если метод вызывается из другого транзакционного метода, будет использована уже существующая транзакция.

-   SUPPORTS (англ. «поддерживается») — это значение указывает Spring, что выполнять метод в режиме транзакции нужно только тогда,
  когда она уже существует. Новую транзакцию создавать не нужно.

-   MANDATORY (англ. «обязательная») — метод будет выполнен при наличии транзакции.
  Если транзакции не существует, метод сгенерирует исключение.

-   NEVER (англ. «никогда») — этот режим является противоположностью предыдущего. Метод не выполнится, если транзакция существует.
  Такой режим полезен, если разработчик точно знает, что для этого метода транзакция не нужна.

-   NOT_SUPPORTED (англ. «не поддерживается») — этот режим менее строгий, чем NEVER.
  В нём уже существующая транзакция будет приостановлена и метод выполнится без транзакции.

-   REQUIRES_NEW (англ. «требуется новая») — в этом режиме существующая транзакция будет приостановлена и создана новая.
  Вызываемый метод будет выполнен в рамках новой транзакции.

-   NESTED (англ. «вложенная») — этот режим не просто приостановит существующую транзакцию.
  Он создаст в ней точку сохранения (англ. savepoint), в которую база данных вернётся, даже если вызываемый метод сгенерирует исключение.

  Эти режимы позволяют эффективно выстраивать логику выполнения транзакционных методов.
С их помощью разработчики Spring решили проблему разделения транзакций на логические (выполняемые и вызываемые транзакционные методы классов и бинов Spring)
и физические (выполняемые SQL-запросы внутри транзакции БД).
