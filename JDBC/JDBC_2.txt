
                                                    Запрашиваем данные

  Обвязка готова. Пора запросить данные пользователя в DAO. Составьте тестовый запрос к базе данных на поиск пользователя с заданным логином tom.
Запрос будет выглядеть так.

select * from cat_user where id = 'tom'

  Реализуйте выполнение этого запроса в методе UserDaoImpl.findUserById(String id) с помощью jdbcTemplate.
Для этого используйте метод queryForRowSet (англ. «запрос набора строк»).
В качестве параметра метод принимает строку запроса и данные для формирования условий запроса (в данном случае параметр login).

@Component
public class UserDaoImpl implements UserDao {
    private final JdbcTemplate jdbcTemplate;

    public UserDaoImpl(JdbcTemplate jdbcTemplate){
        this.jdbcTemplate=jdbcTemplate;
    }

    @Override
    public Optional<User> findUserById(String id) {
        // выполняем запрос к базе данных. Результат пока игнорируем, мы будем работать с ним позже в этом уроке
        SqlRowSet userRows = jdbcTemplate.queryForRowSet("select * from cat_user where id = ?", id);
        // вы заполните данные пользователя в следующем уроке
        User user = new User();
        user.setId(id);
        return Optional.of(user);
    }
}

  queryForRowSet используется для получения результата запроса в самой простой форме — как раз подходит для начала работы UserDao.
Обратите внимание: конкретное значение поля id в запросе (tom) было заменено на знак вопроса.
С помощью него задаются пользовательские условия. Знаков вопроса будет столько,
сколько должно быть передано параметров в метод query после самого запроса.
  Может показаться, что использовать параметры запроса необязательно — достаточно сложить строки "select * from cat_user where id = '"+login+"'",
а затем передать в метод query. Однако это плохая практика — избегайте её.
Такой способ позволяет передать в БД любую строку запроса, которая пришла в контроллер.
При определённых условиях злоумышленники могут провести атаку под названием SQL Injection (англ. «инъекция SQL»).
В ходе неё осуществляется внедрение в запрос произвольного SQL кода.
Например, строчки ; drop database;, которая удалит все таблицы вместе с данными.

                                              Обрабатываем результат

  JdbcTemplate может вернуть результат запроса разными способами. Подробнее об этом будет рассказано далее.
Сейчас мы использовали наиболее общий вариант получения данных — с помощью метода queryForRowSet.
  При ответе на запрос БД формирует данные в виде набора строк, поэтому для получения результата можно применить интерфейс SqlRowSet.
Это Spring-обёртка над базовым классом java.sql.ResultSet.
Класс SqlRowSet (как и его аналог ResultSet) — итератор для списка строк, который прислала БД в ответ на запрос.

  Строка из базы данных — не строка текста, которая обычно имеет тип String.
Это строка таблицы, которая называется row (англ. «ряд». Однако русскоязычные программисты говорят «строка»).
Она состоит из множества значений колонок. С помощью row можно обработать набор колонок, а также данные в отдельной колонке конкретной строки.
При этом колонка запрашивается по имени или порядковому номеру.

  Проверьте результат запроса пользователя tom. Добавьте логгер и проверку итератора на наличие результата.


  @Component
  public class UserDaoImpl implements UserDao {
      private final Logger log = LoggerFactory.getLogger(UserDaoImpl.class);

      private final JdbcTemplate jdbcTemplate;

      public UserDaoImpl(JdbcTemplate jdbcTemplate){
          this.jdbcTemplate=jdbcTemplate;
      }

      @Override
      public Optional<User> findUserById(String id) {
          // выполняем запрос к базе данных.
          SqlRowSet userRows = jdbcTemplate.queryForRowSet("select * from cat_user where id = ?", id);
          if(userRows.next()) {
              log.info("Найден пользователь: {} {}", userRows.getString("id"), userRows.getString("nickname"));
              // вы заполните данные пользователя в следующем уроке
              User user = new User();
              user.setId(id);
              // My decision...
              user.setNickname(userRows.getString("nickname"));
              user.setUsername(userRows.getString("username"));
              // My decision...
              return Optional.of(user);
          } else {
              log.info("Пользователь с идентификатором {} не найден.", id);
              return Optional.empty();
          }
      }
  }

  Поля, которые нужно найти в результате запроса, известны. Их можно запросить у объекта userRows с помощью метода getString.
Метод выбран не случайно — поля id и nickname в таблице cat_user имеют строковый тип varchar.
  Если всё сделано правильно, после выполнения запроса вернётся объект типа SqlRowSet с одним элементом.
Чтобы получить доступ к данным пользователя tom, этот объект достаточно запросить через вызов метода next().
Когда итератор установлен на строчку tom, можно обратиться к методу getString и получить все значения.
Затем их можно будет вывести в консоль.
  Сейчас мы сосредоточились на данных одного пользователя. Однако способ получения множества результатов будет похожим.
За это отвечает метод next(). Он переводит итератор на следующий элемент и возвращает true или false
в зависимости от наличия этого элемента в итераторе.
Такой способ позволяет программе перемещаться по результатам запроса в цикле.
