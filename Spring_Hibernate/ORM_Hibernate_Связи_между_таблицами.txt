
  Есть способ избежать дополнительных ручных запросов и позволить ORM самостоятельно загружать и обновлять связанные сущности.
В этом помогут связи «один-к-одному» (@OneToOne), «один-ко-многим» (@OneToMany), «многие-к-одному» (@ManyToOne) и «многие-ко-многим» (@ManyToMany).
Самый простой и распространённый вариант — связь «многие-к-одному».

                                                    ManyToOne


                                                      User          one
                                                       |
                                                  _____|_____        to
                                                 |     |     |
                                               Item   Item  Item    many


  В коде для реализации связи «многие-к-одному» используют аннотацию @ManyToOne. Она применяется на стороне дочернего объекта.

class Item {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    // остальные поля
}

  Смысл аннотации @JoinColumn тот же, что и при использовании @ElementCollection: мы указываем, по какому полю в таблице с пользователями будут объединены таблицы.
В нашем примере использовано поле user_id, которое мы хранили здесь ранее.

 (Если не указать аннотацию @JoinColumn, по умолчанию в качестве поля для связи будет использовано поле с таким названием: имяПоля_названиеПервичногоКлюча.
  В нашем примере получился бы всё то же user_id, поэтому аннотацию @JoinColumn можно было опустить)

===================================================================================================================

*  Рассмотрим, как будет происходить добавление имени пользователя к ItemDto (Со связью между таблицами)

  Item item = repository.findById(itemId).orElseThrow(() -> new IllegalStateException("Item not found"));
  User user = item.getUser();
  String userName = user.getFirstName() + " " + user.getLastName();
  return ItemMapper.mapToItemDto(item, userName);

*  Рассмотрим, как будет происходить добавление имени пользователя к ItemDto (Без связи между таблицами)

  Item item = repository.findById(itemId).orElseThrow(() -> new IllegalStateException("Item not found"));
  long userId = item.getUserId();
  User user = userRepository.findById(userId).orElseThrow(() -> new IllegalStateException("Owner not found"));
  String userName = user.getFirstName() + " " + user.getLastName();
  return ItemMapper.mapToItemDto(item, userName);

===================================================================================================================

                                      Ассоциации между сущностями в JPQL-запросах

  Ассоциации между сущностями можно применять в том числе и при написании JPQL-запросов.
В этом случае можно напрямую использовать поля связанных сущностей внутри запроса — это существенно расширит его возможности.
  Допустим, нужно выбрать все Item, у которых фамилия пользователя начинается с определённого префикса.
Можно использовать следующий метод:

@Query("select it " +
            "from Item as it "+
            "join it.user as u " +
            "where u.lastName like concat(?1, '%') ")
List<Item> findItemsByLastNamePrefix(String lastNamePrefix);

  Обратите внимание: чтобы использовать внутри запроса поля объекта user, нужно явно указать join с сущностью User.
Это поможет ORM правильно выбрать тип используемого соединения таблиц (в нашем примере это будет внутреннее соединение) и эффективнее построить запрос.
Затем можно обращаться в запросе к полям объекта User с помощью точечной нотации. То есть так, как если бы это были обычные Java-объекты.

===================================================================================================================

                                  Ассоциации между сущностями в запросных методах

  При формировании запросных методов тоже можно использовать возможности ORM, которые дают связи между сущностями.
Например, запрос для поиска Item по префиксу фамилии пользователя можно описать с помощью такого запросного метода:

List<Item> findAllByUserLastNameStartingWith(String lastNamePrefix);

Разберём название этого метода:

-    findAllBy — стандартное начало запросного метода Spring Data для выгрузки коллекции объектов;
-    User — название связанной сущности, поле которой собираемся использовать;
-    LastName — название поля, которое принадлежит связанной сущности;
-    StartingWith — предикат; указывает, что нужно найти все строки, у которых lastName начинается на переданный текст.

  Так как между объектами Item и User установлена связь, ORM корректно обработает подобную конструкцию и вернёт нужные данные.

                                                Другие виды связей

  Связи между сущностями — мощный инструмент ORM. Он даёт много возможностей и может заметно упростить разработку кода.
Однако при использовании связей следует соблюдать осторожность и контролировать то, что ORM делает за вас.
  В некоторых случаях связи между сущностями могут вызвать лишние запросы к базе данных.
Например, в случае обновления либо получения связанных сущностей там, где в этом нет необходимости.
Такие запросы негативно повлияют на производительность приложения.

  Связь @ManyToOne — наиболее часто используемая и безопасная с точки зрения производительности.
Однако такие виды связей, как @OneToMany и @ManyToMany, тоже могут быть полезны.
Почитайте о них в этой статье:

https://thorben-janssen.com/ultimate-guide-association-mappings-jpa-hibernate/
