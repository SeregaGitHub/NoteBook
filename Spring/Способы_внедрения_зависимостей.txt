                                                  Способы внедрения зависимостей

  Внедрять зависимости с помощью аннотации @Autowired можно не только через конструктор, но и через поля и методы.
Разберём достоинства и недостатки разных способов, а также какие из них когда лучше использовать.

                                            1. Напрямую в поля (англ. field injection)

  Внедрение зависимости напрямую в поле объекта с помощью аннотации @Autowired будет выглядеть так.

@Component
public class MyCar {
    @Autowired
    private Engine engine;
}

  Главный плюс внедрения зависимости напрямую в поле класса — краткость. Однако минусов у такого подхода намного больше.

-  Нельзя использовать final-поля, так как, чтобы внедрение зависимости произошло, поле должно оставаться изменяемым.
-  Сложнее тестировать — в рамках инкапсуляции поля, как правило, закрыты модификатором private, а значит, к ним нет прямого доступа,
   из-за этого подменить зависимость на тестовую не получится.
-  Если бина нет в контейнере, то поле будет равно null, но об этом станет известно только при попытке к нему обратиться.
-  Есть соблазн перегрузить класс зависимостями — поставить @Autowired перед несколькими полями куда проще,
   чем использовать конструктор с большим количеством параметров.

  Сейчас внедрение зависимостей в поля используется всё реже, но его можно встретить в старых проектах.
Команда Spring вообще не рекомендует использовать этот способ и указывает основными способами внедрение через конструктор и методы-сеттеры.

                                    2. Через методы-сеттеры (англ. setter-based dependency injection)

  Так как методы-сеттеры позволяют поменять значение поля, через них можно и внедрить зависимость.
В этом случае аннотация @Autowired будет стоять перед методом.

@Component
public class MyCar {
    private Engine engine;

    @Autowired
    public void setEngine(Engine engine) {
        this.engine = engine;
    }
}

  Сначала Spring с помощью конструктора по умолчанию создаст объект класса, затем вызовет метод-сеттер, помеченный @Autowired,
и передаст через него нужный бин. Если сеттеров с аннотацией @Autowired несколько, то Spring вызовет их все.

Недостатки внедрения зависимостей через сеттеры:

-  Всё ещё нельзя использовать final-поля, так как сеттер вызывается уже после создания объекта и требуется, чтобы поле было изменяемым.
-  Есть риск упустить зависимость — забыть добавить сеттер с @Autowired. В этом случае поле окажется пустым и программа может дать сбой.

  Одно из важных достоинств внедрения зависимостей через сеттеры — возможность работать с циклическими зависимостями
(подробнее о них речь пойдёт в следующем уроке).

                                3. Через конструктор (англ. constructor-based dependency injection)

  Третий, уже знакомый вам способ, — внедрение зависимостей через конструктор.

@Component
public class MyCar {
    private final Engine engine;
    private final Wheels wheels;
    private final Radio radio;

    @Autowired
    public MyCar(Engine engine, Wheels wheels, Radio radio) {
        this.engine = engine;
        this.wheels = wheels;
        this.radio = radio;
    }
}

  В этом случае Spring IoC-контейнер считывает параметры конструктора, находит или создаёт соответствующие им бины,
затем вызывает конструктор и передаёт их туда.
  Команда разработчиков Spring рекомендует всегда использовать внедрение через конструктор как самый надёжный способ.
Во-первых, поля класса могут быть final, что как раз делает программу более надёжной.
Во-вторых, нет сложностей с тестированием — зависимость всегда можно подменить на тестовую.

Недостатки у внедрения зависимостей через конструктор также есть:

-  При большом количестве параметров конструктор получается более громоздким.
   Особенно хорошо это видно в сравнении с внедрением зависимостей напрямую в поля.
-  Конструктор для внедрения зависимостей может быть только один.
   Когда объект создаётся через new, конструктор выбирается по числу и типу переданных аргументов.
   Но в случае автоматического создания объекта через Spring алгоритм подбора конструктора достаточно сложный.
   Поэтому, если нужно, чтобы было несколько разных конструкторов (такая необходимость обычно не возникает),
   тогда только один из них можно аннотировать @Autowired. Если конструктор только один,
   то он и будет использован для внедрения зависимостей, его даже необязательно помечать @Autowired.

                                  4. Через Lombok и аннотацию @RequiredArgsConstructor

  Чтобы скомбинировать краткость внедрения зависимостей через поля с надёжностью внедрения через конструктор,
можно использовать библиотеку Lombok и аннотацию @RequiredArgsConstructor.

   @Component
   @RequiredArgsConstructor
   public class MyCar {
       private final Engine engine;
       private final Wheels wheels;
       private final Radio radio;

       // логика
   }

  Увидев аннотацию @RequiredArgsConstructor, Lombok создаст примерно такой же конструктор,
который был бы при внедрении через конструктор, только без аннотации @Autowired.

   // Внедрение через конструктор
   @Component
   public class MyCar {
       private final Engine engine;
       private final Wheels wheels;
       private final Radio radio;

       // примерно такой же конструктор создаст Lombok
       public MyCar(Engine engine, Wheels wheels, Radio radio) {
           this.engine = engine;
           this.wheels = wheels;
           this.radio = radio;
       }

       // логика
   }

  Spring будет использовать сгенерированный Lombok конструктор, поскольку он единственный.
При таком подходе не нужно вручную самостоятельно писать конструктор со всеми параметрами,
код получается достаточно кратким плюс не нужно писать @Autowired у каждого поля.
Поля при этом могут быть final, что делает программу надёжной.

                                      5. Комбинирование разных способов

  Можно комбинировать внедрение зависимостей разными способами.

@Component
public class MyCar {
    private final Engine engine;
    @Autowired private Wheels wheels;
    private Radio radio;

    @Autowired
    public MyCar(Engine engine) {
        this.engine = engine;
    }

    @Autowired
    public void setRadio(Radio radio) {
        this.radio = radio;
    }
}

  В таком случае Spring сначала заведёт двигатель — вызовет конструктор, передаст в него Engine,
потом включит радио — вызовет сеттер setRadio(Radio radio) и запустит колёса — присвоит значение в поле Wheels wheels.
Конструктор всегда вызывается первым, а вот порядок между полями и сеттерами может быть любым.

  Такой смешанный подход не рекомендуется использовать, так как код становится сложным для чтения.
Разработчик может пропустить зависимость — увидеть в конструкторе и не заметить в сеттере.
